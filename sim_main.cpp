#include "Vriscv_top.h"
#include "Vriscv_top___024root.h"
#include "verilated.h"
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>

// Clock period doesn't matter for Verilator (we manually toggle)
// We just count cycles.

uint64_t main_time = 0;
double sc_time_stamp() { return main_time; }

// -------------------------------------------------------
// Load a hex file into the memory model
// The hex file is 128-bit wide (32 hex chars per line)
// Generated by riscv64-unknown-elf-bin2hex -w 128
// -------------------------------------------------------
void load_hex(Vriscv_top *top, const char *filename) {
  FILE *f = fopen(filename, "r");
  if (!f) {
    fprintf(stderr, "ERROR: Cannot open hex file: %s\n", filename);
    exit(1);
  }

  char line[256];
  int addr = 0;

  while (fgets(line, sizeof(line), f)) {
    // Remove newline
    line[strcspn(line, "\r\n")] = 0;
    if (strlen(line) == 0)
      continue;

    // Parse 128-bit hex value (32 hex chars)
    // Each line is one 128-bit word
    // We need to write this into the memory arrays
    // For no_cache_mem mode: dut.mem.icache.ram and dut.mem.dcache.ram
    // The ram is indexed by 128-bit words

    // Parse the 128-bit value as 4 x 32-bit words
    uint32_t words[4] = {0, 0, 0, 0};
    int len = strlen(line);

    // Hex string is big-endian: leftmost chars are MSB
    // words[3] = bits[127:96], words[2] = bits[95:64],
    // words[1] = bits[63:32],  words[0] = bits[31:0]
    for (int i = 0; i < len && i < 32; i++) {
      int nibble;
      char c = line[len - 1 - i];
      if (c >= '0' && c <= '9')
        nibble = c - '0';
      else if (c >= 'a' && c <= 'f')
        nibble = c - 'a' + 10;
      else if (c >= 'A' && c <= 'F')
        nibble = c - 'A' + 10;
      else
        continue;

      int word_idx = i / 8;
      int bit_pos = (i % 8) * 4;
      words[word_idx] |= (nibble << bit_pos);
    }

    // Write into icache and dcache memory
    // In no_cache_mem mode, both share the same address space
    // ram is 128-bit wide, indexed by address
#ifdef NO_CACHE_MEM
    top->riscv_top->mem->icache->ram[addr] =
        ((uint64_t)words[1] << 32) | words[0];
    // no_cache_mem uses a different storage format - we need internal access
    // Actually, Verilator exposes arrays differently. Let's use DPI or
    // direct array access.
#endif
    // We'll use a different approach - see below
    addr++;
  }
  fclose(f);
}

int main(int argc, char **argv) {
  Verilated::commandArgs(argc, argv);

  // Parse arguments
  const char *hex_file = nullptr;
  uint64_t max_cycles = 50000000; // 50M cycles default
  bool verbose = false;

  for (int i = 1; i < argc; i++) {
    if (strncmp(argv[i], "+loadmem=", 9) == 0) {
      hex_file = argv[i] + 9;
    } else if (strncmp(argv[i], "+max-cycles=", 12) == 0) {
      max_cycles = atoll(argv[i] + 12);
    } else if (strcmp(argv[i], "+verbose") == 0) {
      verbose = true;
    }
  }

  if (!hex_file) {
    fprintf(stderr, "Usage: %s +loadmem=<hexfile> [+max-cycles=N] [+verbose]\n",
            argv[0]);
    return 1;
  }

  // Create model
  Vriscv_top *top = new Vriscv_top;

  // ---------------------------------------------------------------
  // Reset phase FIRST â€” this triggers Verilator's `initial` blocks
  // which zero all RAM in no_cache_mem. We must do this BEFORE
  // loading the hex file, or the initial block will wipe our data.
  // ---------------------------------------------------------------
  top->reset = 1;
  top->clk = 0;
  for (int i = 0; i < 100; i++) {
    top->clk = !top->clk;
    top->eval();
    main_time++;
  }
  top->reset = 0;

  // ---------------------------------------------------------------
  // NOW load hex file into memory (after initial blocks have run)
  // ---------------------------------------------------------------
  FILE *f = fopen(hex_file, "r");
  if (!f) {
    fprintf(stderr, "ERROR: Cannot open hex file: %s\n", hex_file);
    return 1;
  }

  // objcopy -O binary strips the base address. The binary starts at VMA 0x2000
  // (PC_RESET). no_cache_mem uses 128-bit (16-byte) indexed RAM, so
  // 0x2000 / 16 = 512. We must load at that offset to match the CPU.
  char line[256];
  int addr = 0x2000 / 16; // must match PC_RESET / (MEM_DATA_BITS/8)
  while (fgets(line, sizeof(line), f)) {
    line[strcspn(line, "\r\n")] = 0;
    if (strlen(line) == 0)
      continue;

    // Parse 128-bit hex into 4 x 32-bit words
    uint32_t words[4] = {0, 0, 0, 0};
    int len = strlen(line);
    for (int i = 0; i < len && i < 32; i++) {
      int nibble;
      char c = line[len - 1 - i];
      if (c >= '0' && c <= '9')
        nibble = c - '0';
      else if (c >= 'a' && c <= 'f')
        nibble = c - 'a' + 10;
      else if (c >= 'A' && c <= 'F')
        nibble = c - 'A' + 10;
      else
        continue;
      int word_idx = i / 8;
      int bit_pos = (i % 8) * 4;
      words[word_idx] |= (nibble << bit_pos);
    }

    // Store as 128-bit value in memory model
    // Verilator stores wide signals as arrays of uint32_t
    // For WData (wide data), index [0] is LSB
    top->rootp->riscv_top__DOT__mem__DOT__icache__DOT__ram[addr][0] = words[0];
    top->rootp->riscv_top__DOT__mem__DOT__icache__DOT__ram[addr][1] = words[1];
    top->rootp->riscv_top__DOT__mem__DOT__icache__DOT__ram[addr][2] = words[2];
    top->rootp->riscv_top__DOT__mem__DOT__icache__DOT__ram[addr][3] = words[3];

    top->rootp->riscv_top__DOT__mem__DOT__dcache__DOT__ram[addr][0] = words[0];
    top->rootp->riscv_top__DOT__mem__DOT__dcache__DOT__ram[addr][1] = words[1];
    top->rootp->riscv_top__DOT__mem__DOT__dcache__DOT__ram[addr][2] = words[2];
    top->rootp->riscv_top__DOT__mem__DOT__dcache__DOT__ram[addr][3] = words[3];

    addr++;
  }
  fclose(f);
  fprintf(stderr, "Loaded %d lines from %s\n", addr - 0x2000 / 16, hex_file);

  // Run simulation
  uint64_t cycle_count = 0;
  uint32_t prev_csr = 0;

  while (cycle_count < max_cycles) {
    // Rising edge
    top->clk = 1;
    top->eval();
    main_time++;
    cycle_count++;

    // Check CSR (tohost)
    uint32_t csr_val = top->csr;

    if (csr_val == 1 && cycle_count > 10) {
      fprintf(stderr, "*** PASSED *** after %llu simulation cycles\n",
              cycle_count);
      break;
    }
    if (csr_val > 1 && cycle_count > 10) {
      fprintf(stderr,
              "*** FAILED *** (tohost = %d) after %llu simulation cycles\n",
              csr_val, cycle_count);
      break;
    }

    // Falling edge
    top->clk = 0;
    top->eval();
    main_time++;
  }

  if (cycle_count >= max_cycles) {
    fprintf(stderr, "*** TIMEOUT *** after %llu simulation cycles\n",
            cycle_count);
  }

  fprintf(stderr, "Total cycles: %llu\n", cycle_count);

  top->final();
  delete top;
  return 0;
}